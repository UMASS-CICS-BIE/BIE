// This is really -*- C++ -*-

#ifndef Tessellation_h
#define Tessellation_h

#include <string>
#include <iostream>

#include <Tile.h>
#include <Node.h>
#include <RecordInputStream.h>

#include "Serializable.h"


using namespace std;

struct compx 
    {
      //! Comparison function
      bool operator()
      (const twodcoords &a, const twodcoords &b) const
      { return a.x<b.x; } 
    };
    
    /// Compares the x values in two twodcoords structures.
    compx compX;
    
    /// Compares the y values in two twodcoords structures.
    struct compy 
    { 
      //! Comparison function
      bool operator()(const twodcoords &a, const twodcoords &b) const
      { return a.y<b.y; } 
    };
    
    /// Compares the y values in two twodcoords structures.
    compy compY;
    
    /// Compares both x and y values in two twodcoords structures for equality
    struct compxy 
    {
      //! The comparsion operator
      bool operator()(const twodcoords &a, const twodcoords &b) const
      { return a.x == b.x  && a.y == b.y; }
    };
    

    /// Hash a twodcoords struct into a single integer by Xoring the bits!
    struct hashCoords
    { 
      //! The hash function
      size_t operator()( const twodcoords &a) const
      { 
  size_t res = 0;
  size_t len = sizeof(a);
  const char* p = reinterpret_cast<const char*>(&a);
  while (len--) res = (res<<2)^*p++;
  return res;
      }
    };
    

namespace BIE {

  //! @defgroup tess Tessellation types 
  //! These classes define various
  //! tessellations of a two-dimensional mapped space
  //! @{

  /// Class to hold two dimensional coordinates.
  class twodcoords: public Serializable 
  {

  public:
    //! Constructor with no values
    twodcoords(){};
    
    //! Constructor with a value pair
    twodcoords(double px, double py): x(px), y(py){}

    /// X coordinate
    double x;
    
    /// Y coordinate
    double y;
    
    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Serializable);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(x);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(y);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  };

  //+ CLICLASS Tessellation
  //! An immutable tessellation of tiles, possibly hierarchical.
  class Tessellation: public Serializable {
  
  public:
    /// Default blank constructor
    Tessellation() {};
  
    /// Destructor.
    virtual ~Tessellation();
    
    /// Retrieve a tile given a tileid
    virtual Tile* GetTile(int tileid);
    
    /// Find all tiles in the tessellation tree with the given coordinates
    virtual void FindAll(double x, double y, vector<int> &found);
    
    /// Return the tile ids of the tree roots in the tessellation forest.  
    /// QuadTree  and Kd have forests with size one.  All MappedGrid
    /// are "root" nodes.
    virtual vector<int> GetRootTiles() = 0;
    
    /// Return the roots of the trees in the tessellation forest.  QuadTree
    /// and Kd have forests with size one.
    virtual vector<Node*> GetRootNodes() = 0;
    
    //+ CLIMETHOD bool IsValidTileID int
    //! Returns true if the tile id is valid for this tessellation
    virtual bool IsValidTileID(int tileid);
    
    //+ CLIMETHOD int MinID 
    //! Returns the lowest tile ID used by the tessellation.
    virtual int MinID() { return 0; }
    
    //+ CLIMETHOD int MaxID 
    //! Returns the highest tile ID used by the tessellation.
    //! We really need an iterator for all tile ids.
    virtual int MaxID() { return NumberTiles() - 1; }
    
    //+ CLIMETHOD int NumberTiles
    //! Returns the total number of tiles in this tessellation.
    virtual int NumberTiles();
    
    /// Print the trees underneath the provided root nodes in
    /// pre-order.
    void PrintPreOrder(vector<Node*> rootnodes, ostream & outputstream);
    
    /// Print the tessellation tree in pre-order.
    void PrintPreOrder(ostream & outputstream);
    
    /// Get map limits
    void GetLimits(double &x1, double &x2, double &y1, double &y2) 
      {
	x1 = Xmin;
	x2 = Xmax;
	y1 = Ymin;
	y2 = Ymax;
      }
    
  protected:
    /// These define the boundary of the tessellation.
    //@{
    double Xmin, Xmax;
    double Ymin, Ymax;
    //@}
    
    /// Tileid indexed list of tiles
    map<int, Tile*> _tiles;
    
    /// Total number of tiles.
    int Ntiles;
    
    /// Prints out the tessellation tree to standard output.
    void PrintPreOrder(Node *tree, ostream & outputstream);
    
    /// Find all children of a node containing the given coordinates
    void findall(double, double, vector<int>&, Node*);
    
    /// Samples a specified percentage of the input stream, and puts the 
    /// sample points into a vector.  
    void compute_sampling (RecordInputStream *, vector<twodcoords>*, 
			   double pts, double minx, double maxx, double miny, double maxy);
    
    /// Compares the x values in two twodcoords structures.
    
    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Serializable);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(Xmin);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(Xmax);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(Ymin);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(Ymax);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(_tiles);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(Ntiles);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

      };    
  
  //! @}

} // namespace BIE

#ifndef SWIG
BIE_CLASS_ABSTRACT(BIE::Tessellation)

BIE_CLASS_TYPE_INFO(BIE::twodcoords)
BIE_CLASS_EXPORT_KEY(BIE::twodcoords)
BIE_CLASS_EXPORT_KEY(BIE::Tessellation)
#endif
#endif
