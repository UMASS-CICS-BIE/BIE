// This is really -*- C++ -*-


#ifndef Converge_h
#define Converge_h

#include <Distribution.h>
#include <Ensemble.h>

#include "Serializable.h"


namespace BIE {

  /** \defgroup converge Convergence algorithms
   *  Classes to assess convergence of the MCMC simulation
   * @{
   */


  //+ CLICLASS Converge SUPER SampleDistribution
  /**
     Abstract class: accumulate statistics on MCMC chain and define a
     boolean method decide convergence
  */
  class Converge : public SampleDistribution 
  {
  protected:

    Ensemble* _dist;

    void setBurnIn(int n) { _dist->burnIn = n; }

  public:

    //! Total number of states
    int count;

    //! Burn-in point
    int nburn;
    //! Constructor for cloning only
    Converge() : _dist(0), count(0), nburn(-1) {}

    //! Main constructor
    Converge(Ensemble* d) : count(0), nburn(-1) { _dist = d; }

    /*
      NB: These members are not declared _pure_ virtual so that a
       pointer to this base class can be instantiated
    */

    //! True if test indicates simulation convergence
    virtual bool Converged() { return false;}

    //! Factory method (for duplicating instances)
    virtual Converge* New(int m, Ensemble* d, string id) {
      return new Converge(d);
    }

    //! Required member (single chain).  This must be overloaded.
    virtual bool AccumData(vector<double>& values, State& state) {
      return true;
    }

    //! Required member (parallel chain). This interatively calls the
    //! single chain method
    virtual bool AccumData(vector< vector<double> >& values, 
			   vector<State>& states) 
    {
      bool ret = true;
      vector< vector<double> >::iterator i1 = values.begin();
      vector<State> ::iterator i2 = states.begin();
      for (; i1!=values.end() && i2!=states.end(); i1++, i2++) {
	if (!AccumData(*i1, *i2)) ret = false;
      }
      return ret;
    }

    //! Required member (single chain).  This should be overloaded.
    virtual bool GetLast(vector<double>& value, State& state) { 
      return false; 
    }

    //! Required member (parallel chain). This should be overloaded.
    virtual bool GetLast(vector< vector<double> >& value, 
			 vector<State>& state) { return false; }

    //! True, if parallel chain data is required
    virtual bool IsParallel() {
      return false;
    }

    //! Required member
    virtual int ConvergedIndex() { return 0; }

    //! Required member but not used here
    bool AccumulateData(double v, RecordBuffer* datapoint) { 
      cerr << "Not implemented for a Convergence statististic . . . \n";
      return false; 
    }

    //+ CLIMETHOD void DumpConverged string 
    /** Dump a converged chain to a user-specified file.  
	If the chain is NOT converged, no file is produced. 

	Note: this method uses the Ensemble class to produce the
	output.  Therefore, if @see Ensemble#keep is smaller than the
	converged chain length, some of the valid states will be
	tabled.
    */
    virtual void DumpConverged(string filename);

    /** Required Distribution members */
    //@{
    double PDF(State& x)          { return _dist->PDF(x);        }
    double logPDF(State& x)       { return _dist->logPDF(x);     }
    vector<double> lower(void)    { return _dist->lower();       }
    vector<double> upper(void)    { return _dist->upper();       }
    vector<double> Mean()         { return _dist->Mean();        }
    vector<double> StdDev()       { return _dist->StdDev();      }
    vector<double> Moments(int m) { return _dist->Moments(m);    }
    State          Sample()       { return _dist->Sample();      }
    //@}
    
    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SampleDistribution);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(_dist);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(count);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(nburn);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  };

  /** @} */
}

#ifndef SWIG
BIE_CLASS_TYPE_INFO(BIE::Converge)
BIE_CLASS_EXPORT_KEY(BIE::Converge)
#endif
#endif
