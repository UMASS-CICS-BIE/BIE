// This is really -*- C++ -*-

#ifndef CDFGenerator_h
#define CDFGenerator_h

#include <KDTree.h>
#include <Ensemble.h>
#include <Distribution.h>

#include "Serializable.h"


namespace BIE {

  /** A pair of double vectors for sampling the CDF

      The first vector saves the probability values and the second the
      parameter vector values.  Currently, the first is a triple
      element vector of the posterior, the likelihood, and the prior.

      A vector will facilate later generalization.

      This class can be easily adapted to creating a CDF from an
      ensemble.
  */
  typedef pair<vector<double>, vector<double> > PairDV;
  
  //! Functionoid for generating the CDF
  class FunctDV
  {
  public:
    //! To sample the CDF    
    virtual PairDV Sampler() = 0;
  };

  /** A typedef for the functionoid pointer

      This is used to define a base-interface for passing a sampler
      function to the CDFGenerator
  */
  typedef FunctDV* FctDVPtr;



  //+ CLICLASS CDFGenerator
  /** Generates a CDF by sampling a distribution and numerically
      computing a measure function.  The inverse lookup is performed
      using a KD tree.

      There are two constructors:
      <ol>
      <li> The first uses a supplied functionoid to sample the target 
      distribution
      <li> The second uses an already sampled MC chain recorded in an 
      Ensemble to build the distribution.
      </ol>
      The latter case presumes that one has a posterior simulation and
      a goodness-of-fit test is desired.  A CDFGenerator instance may
      either be constructed in the CLI or in a user-defined likelihood
      function.
  */
  class CDFGenerator: public Serializable 
  {
  private:
    boost::shared_ptr<KDTree> kd;
    vector<double> maxP;

  public:

    //! Default blank constructor
    CDFGenerator() {}
  
    //! Constructor from a sampler function
    CDFGenerator(int N, int ncut, FctDVPtr f);
  
    //+ CLICONSTR int int Ensemble*
    //+ CLICONSTR int int Ensemble* int
    //! Constructor from an ensemble
    CDFGenerator(int N, int ncut, Ensemble* ens, int nburn=0);
  
    //! Force runtime binding of inherited destructor
    virtual ~CDFGenerator() {}
    
    /// @name Get the CDF
    //@{
    /// Mixture case
    double FTheta(vector<double>& data,	vector<double>& wght,
		  vector< vector<double> >& loc,
		  vector< vector<double> >& scl);

    /// Non-mixture case
    double FTheta(vector<double>& data,
		  vector<double>& loc,
		  vector<double>& scl);
    //@}

    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Serializable);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(kd);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(maxP);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

 };
  
} // namespace BIE

#ifndef SWIG
BIE_CLASS_EXPORT_KEY(BIE::CDFGenerator)
#endif
#endif

