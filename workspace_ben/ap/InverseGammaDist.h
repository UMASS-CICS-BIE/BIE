// This is really -*- C++ -*-

#ifndef InverseGammaDist_h
#define InverseGammaDist_h

#include <cfloat>
#include <cmath>

#include <Distribution.h>
#include <Gamma.h>

#include "Serializable.h"


extern double gamma_p(double x, double nu);

namespace BIE {
  
/**
   Weibull distribution with specified scale and shape parameters
   @addtogroup distribution
*/
//+ CLICLASS InverseGammaDist SUPER Distribution
class InverseGammaDist : public Distribution {
 
public:
  
  /// Null constructor
  InverseGammaDist();
  
  /// Main (useful) constructor
  //+ CLICONSTR
  //+ CLICONSTR double double
  //+ CLICONSTR double double double double
  InverseGammaDist(double a, double b, double minv=0.0, double maxv=DBL_MAX);
  
  /// Destructor
  virtual ~InverseGammaDist() {}

  /// Object factor (clone)
  Distribution* New();
  
  /// Differential distribution function P(x)
  virtual double PDF(State& x);
  
  /// Log of differential distribution function P(x)
  virtual double logPDF(State& x);
  
  /// Cumulative distribution function P(>x)
  virtual double CDF(State& x);

  /// Lower bound on distribution (in each dimension)
  virtual vector<double> lower(void);

  /// Upper bound on distribution (in each dimension)
  virtual vector<double> upper(void);

  /// Return mean of distribution (mulitvariate)
  virtual vector<double> Mean(void);

  /// Return standard deviation of distribution (mulitvariate)
  virtual vector<double> StdDev(void);

  /// Return specifided momemnt of distribution (mulitvariate)
  virtual vector<double> Moments(int i);

  /// Return random variate from distribution
  virtual State Sample(void);  

private:
  double mean;
  double var;

  /// scale and shape parameters
  double alpha, beta;
  double vmin, vmax;
  double qmin, qmax;
  double norm, mincdf, maxcdf;
  GammaPtr ugam;

  #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Distribution);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(mean);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(var);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(alpha);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(beta);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(vmin);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(vmax);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(qmin);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(qmax);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(norm);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(mincdf);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(maxcdf);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(ugam);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

};

} // namespace BIE
#ifndef SWIG
BIE_CLASS_TYPE_INFO(BIE::InverseGammaDist)
BIE_CLASS_EXPORT_KEY(BIE::InverseGammaDist)
#endif
#endif
