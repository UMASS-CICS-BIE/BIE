// This is really -*- C++ -*-


#ifndef Histogram1D_h
#define Histogram1D_h

#include <SmplHist.h>
#include <Distribution.h>

#include "Serializable.h"


namespace BIE {

//! Instances of BIE::Bin define histogram bins.
class Bin: public Serializable {

public:
  //! Null constructor
  Bin() {};
  
  //! Define bin values
  //@{
  //! bottom edge
  double bot;
  //! bin center
  double center;
  //! top edge
  double top;
  //! container value
  double val;
  //@}
  
  /** Less than operator used by the STL algorithm lower_bound to find
      the value
  */
  bool operator<(const double& x) const {
    return(x<top && x>bot);
  }

  #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Serializable);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(bot);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(center);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(top);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(val);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

};
  
/**
  Implements a histogram that supports access as a cumulative
 histogram.  This uses a class in the libsrnd library to implement the
 histogram and compute its statistics.
*/
class CumSampleHistogram : public SampleHistogram 
{

private:
  bool accum;

  void compute_accum(void);
  
  int n;
  vector<Bin> cum;
  vector<double> bin;
  
public:
  //! The constructor
  CumSampleHistogram(double low, double hi, double bucketWidth = -1.0) :
    SampleHistogram(low, hi, bucketWidth) { accum = false; }
  
  //! Get the value below fraction @param s
  double quartile(double s);

  //! Get the fraction below value @param s
  double fraction(double s);

  #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    protected:
    CumSampleHistogram() {}
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SampleHistogram);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(accum);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(n);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(cum);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(bin);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

};

//+ CLICLASS Histogram1D SUPER BinnedDistribution
//! This class is used to create one dimensional histograms.
class Histogram1D : public BinnedDistribution 
{

private:
  
  CumSampleHistogram * ch;
  double low, high, width, toplimit;
  double val;

  bool AccumulateData(double v, vector<double> & x);
  bool AccumulateData(double v, RecordBuffer * datapoint);
  
  //! Common initialization for constructors.
  void initialize(double low, double high, double width);
  
public:
  //+ CLICONSTR double double double RecordType*
  /** The arguments specify the low bound of the histogram, the high bound
      of the histogram, the width of each bin, and the type of the 
      single attribute respectively.
  */
  Histogram1D(double low, double hi, double w, RecordType * type);

  //+ CLICONSTR double double double string
  /** The arguments specify the low bound of the histogram, the high
      bound of the histogram, the width of each bin, and the name of
      the single attribute respectively.
  */
  Histogram1D(double low, double hi, double w, string dataname);

  //! Destructor: cleans up the allocations.
  ~Histogram1D();

  //! Cloning/Instance factory method.
  Histogram1D* New();

  //! Return the value of the partial distribution function at @param x
  double PDF(vector<double>& x) 
    {return ch->similarSamples(x[0])/width;}

  //! Return log value of the partial distribution function at @param x
  double logPDF(vector<double>& x) 
    {return log(ch->similarSamples(x[0])/width);}

  //! Return cumulative distribution function at @param x
  double CDF(vector<double>& x) {return ch->fraction(x[0]);}

  //! Return the low bin values
  vector<double> lower(void) {return vector<double>(1, ch->min());}

  //! Return the high bin values
  vector<double> upper(void) {return vector<double>(1, ch->max());}

  //! Return the mean bin value
  vector<double> Mean(void) {return vector<double>(1, ch->mean());}

  //! Return the standard deviaton about the mean  bin value
  vector<double> StdDev(void) {return vector<double>(1, ch->stdDev());}

  //! Return ith moment of bin values
  vector<double> Moments(unsigned i) {
    if (i==0) return vector<double>(1, 1.0);
    if (i==2) return vector<double>(1, ch->stdDev()*ch->stdDev() + ch->mean()*ch->mean());
    return vector<double>(1, ch->mean());
  }
  
  //! Sample the histogram
  State Sample(void) { 
    cerr << "Histogram1D::Sample: Not implemented\n";
    return vector<double>(1, 0.0);
  }
  
  //! Compute the statistical summary
  void ComputeDistribution();

  //! Returns the number of in-bounds bins
  int numberData() {
    return ch->buckets()-2;
  }
    
  //! Returns the value of a particular bin.
  double getValue(unsigned i) {
    if (i<0) i=0;
    if (i>=static_cast<unsigned>(ch->buckets())-2) 
      i=static_cast<unsigned>(ch->buckets())-3;
    return (double)ch->inBucket(i+1);
  }

  //! Returns the lower boundary of a bin.
  vector<double> getLow(unsigned i) {
    if (i<0) i=0;
    if (i>=static_cast<unsigned>(ch->buckets())-2) 
      i=static_cast<unsigned>(ch->buckets())-3;
    return vector<double>(1, ch->bucketThreshold(i));
  }

  //! Returns the upper boundary of a bin.
  vector<double> getHigh(unsigned i) {
    if (i<0) i=0;
    if (i>=static_cast<unsigned>(ch->buckets())-2) 
      i=static_cast<unsigned>(ch->buckets())-3;
    return vector<double>(1, ch->bucketThreshold(i+1));
  }
  
  //! Returns the dimensionality of the histogram - always 1.
  int getdim(unsigned i) {return 1;}

  #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    protected:
    Histogram1D() {}
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(BinnedDistribution);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(ch);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(low);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(high);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(width);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(toplimit);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(val);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

};

} // namespace BIE
#ifndef SWIG
BIE_CLASS_TYPE_INFO(BIE::Bin)
BIE_CLASS_TYPE_INFO(BIE::CumSampleHistogram)
BIE_CLASS_TYPE_INFO(BIE::Histogram1D)
BIE_CLASS_EXPORT_KEY(BIE::Bin)
BIE_CLASS_EXPORT_KEY(BIE::CumSampleHistogram)
BIE_CLASS_EXPORT_KEY(BIE::Histogram1D)
#endif
#endif
