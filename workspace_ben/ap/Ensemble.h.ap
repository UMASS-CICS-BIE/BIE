// This is really -*- C++ -*-

#ifndef Ensemble_h
#define Ensemble_h

#include <values.h>		// For MAXINT
#include <deque>
#include <map>

#include <BIEconfig.h>
#include <ACG.h>
#include <Uniform.h>
#include <Normal.h>
#include <DiscUnif.h>
#include <Distribution.h>
#include <VectorM.h>

@include_persistence

using namespace std;

namespace BIE {
  
  //! @defgroup ensembles Ensembles of states
  //! These classes maintain the simulation output and provide
  //! diagnostics and density estimates from the target distribution

  //@{
  /** Work arounds for problems with map save/restore 
      
      I suspect that this is still my problem but I broke down the map
      serialization to look for clues and then there was no problem.
      So until more clues arise, I'll stick with this as a work
      around.
  */
#define SAVEDMDV(val, TUV)                                              \
  {                                                                     \
    size_t msz = val.size();                                            \
    try {                                                               \
      ar << BOOST_SERIALIZATION_NVP(msz);                               \
      BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                          \
    }                                                                   \
    std::map<int, TUV>::const_iterator it;                              \
    for (it=val.begin(); it!=val.end(); it++) {                         \
      int one = it->first;                                              \
      TUV two = it->second;                                             \
      try {                                                             \
        ar << BOOST_SERIALIZATION_NVP(one);                             \
        BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                        \
      }                                                                 \
      try {                                                             \
        ar << BOOST_SERIALIZATION_NVP(two);                             \
        BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                        \
      }                                                                 \
    }                                                                   \
  }


#define RESTRMDV(val, TUV)                                              \
  {                                                                     \
    size_t msz;                                                         \
    try {                                                               \
      ar >> BOOST_SERIALIZATION_NVP(msz);                               \
      BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                          \
    }                                                                   \
    for (size_t i=0; i<msz; i++) {                                      \
      int one;                                                          \
      TUV two;                                                          \
      try {                                                             \
        ar >> BOOST_SERIALIZATION_NVP(one);                             \
        BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                        \
      }                                                                 \
      try {                                                             \
        ar >> BOOST_SERIALIZATION_NVP(two);                             \
        BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                        \
      }                                                                 \
      val[one] = two;                                                   \
    }                                                                   \
  }
  //@}

  /** StateData
      of the posterior simulation including the posterior probability,
      the component weights and parameter vectors.
      
      @see Ensemble
      @ingroup ensembles
  */
  class @persistent_root(StateData)
  {
  public:
    
    //! Probability values
    vector<double> @autopersist(prob);
    
    //! State
    State @autopersist(p);
    
    /**
       Constructor takes each of the public variables M, prob, weight,
       phi as arguments
    */
    //@{
    //! Null constructor
    StateData() {}

    //! Default constructor
    StateData(StateInfo *si) { 
      prob = vector<double>(3, 0); 
      p = State(si);
    };
    //! Construct from a probability, likelihood, prior and a state
    StateData(vector<double>&, State&);

    //! Copy constructor
    StateData(const StateData&);
    //@}

    //! MPI copy
    void Broadcast();

    @persistent_end
  };
  
  /** PairIndex
      saves key, index pair for finding the probability given the
      state

      @ingroup ensembles
  */
  class @persistent_root(PairIndex)
  {
  public:
    //! Default constructor
    PairIndex() { };

    //! The index value
    int    @autopersist(index);

    //! The data value
    double @autopersist(value);

    //! True if the values are sufficiently close
    bool operator==(PairIndex t)
    {
      return (fabs(value - t.value)/(fabs(value) + fabs(t.value)) < 1.0e-12);
    }

    @persistent_end
  };

  /** StateCache
      maintains a list of MCMC states and allows sampling and searching
      on the list by mixture subspace

      @ingroup ensembles
  */
  class @persistent_root(StateCache)
  {
  private:

    int @autopersist(begin), @autopersist(key_pos);
    int @autopersist(count), @autopersist(cur_index);
    int @autopersist(ssize);
    deque<StateData> * @autopersist(states);
    map<int, vector<PairIndex> > @autopersist(pairs);
    map<int, DiscUnifPtr> @autopersist(disc);

  public:
    
    //! Constructor: Initialize with a deque of states
    StateCache(int nburn, deque<StateData>& states, int keypos=0);

    //! Copy constructor
    StateCache(const StateCache&);

    //! Destructor
    virtual ~StateCache() {}

    //! Mean per subspace
    vector<double> Mean(unsigned m);

    //! Sample a state at random from the list for a given subspace
    State Sample(unsigned m);

    //! Return the probability of the state with state vector P
    double logPDF(State &P);

    //! Return the size of the cache
    unsigned size() { return states->size(); }

    //! Return the size of the cached vector
    unsigned stateSize() { return ssize; }

    @persistent_end
  };
  

  //+ CLICLASS Ensemble SUPER SampleDistribution
  //! Ensemble caches an group of posterior states in a vector and
  //! provides member functions to characterize the posterior from
  //! this distribution and produce statistical diagnostics on the
  //! convergence of the simulation.
  //!
  //! The posterior state is characterized from the ensemble variance
  //! by a principal component analysis.
  //!
  //! @ingroup ensembles
  //!
  class @persistent(Ensemble) : public @super(SampleDistribution) 
  {
    friend class Converge;

  protected:
    //! Number of components in the state
    StateInfo *@autopersist(_si);

    //@{
    //! The number of states used in the distribution
    typedef map<int, int> mapII;
    typedef map<int, int>::iterator mapIIiter;
    mapII @autopersist(cnts);
    //@}

    //! State variables and vectors
    //@{
    //! Total count
    int @autopersist(count);

    //! Offset of current count list from zero
    int @autopersist(offset);

    //! Offset at convergence
    int @autopersist(burnIn);

    //! Currently unused (remove?)
    int @autopersist(ibeg);

    //! Level on creation
    int @autopersist(clev);

    //! Number of states in each subspace
    set<int> @autopersist(npop);

    //@{
    //! Fraction of states in each subspace
    typedef map<int, double> mapID;
    typedef map<int, double>::iterator mapIDiter;
    map<int, double> @autopersist(ccum);
    //@}

    //@{
    //! For sampling
    typedef map< int, pair<double, int> > fracMap;
    typedef map< int, pair<double, int> >::iterator fracMapIter;
    vector<int> @autopersist(MM);
    fracMap     @autopersist(fraction);
    //@}

    //! State cache
    deque<StateData> @autopersist(states);

    //! Uniform random number generator
    UniformPtr @autopersist(unit);

    /** True if the ensemble has had its mixture cardinality and model
	dimension set somehow (either in the constructor or by the
	member function) */
    bool @autopersist(dimensions_set);
    
    //! Verbose output
    bool @autopersist(verbose);

    //! Count instances
    static int @autopersist(instance);

    //! Local instance number
    int @autopersist(_id);

    //! Make fraction map for sampling and initialize subspace stats
    virtual void makeSampleFraction();

    //! Debug state dump: true to enable, false to disable
    bool @autopersist(enable_dump);

    //! True for binary dump file, false for ascii dump file
    bool @autopersist(binary_dump);

  public:
    /** Global variables */
    //@{

    //! Toggle verbose output for debugging (Default: false)
    static bool @autopersist(verbose_debug);

    //! Default verbose output is on (Default: false)
    static bool @autopersist(verbose_default);

    //! Number of states to retain (FIFO queue, default=400,000)
    static int @autopersist(keep);
    
    //! Minimum number of states per subspace to retain subspace (default 3)
    static int @autopersist(minsub);

    //! Principal component threshold (default=1.0e-12)
    static double @autopersist(thresh);

    /** For variable component mixtures, specify whether to determine
	the range of continuously adjacent non-zero components
	(continuous=true, default) or the minimum and maximum
	(allowing for the possibility of zero frequency component
	counts (continuous=false).  These can be set in the CLI using
	the SetContinuous and SetMaxRange member functions
    */
    static bool @autopersist(continuous);

    //! Which element of parameter vector to be used as index key (default=0)
    static int @autopersist(key_pos);

    //@}

    
    //! Constructor
    Ensemble();

    /** Mixture constructor
	\param si points to the metadata for the state structure
    */
    Ensemble(StateInfo* si);

    /** General constructor
	\param si is a pointer to the state metainfo instance
	\param level is the update level
	\param nburn is the desired number of converged states
	\param filename is the logfile for ensemble statistics
	\param keypos is the parameter index for computing PDF and CDF 
	evaluations 
    */
    Ensemble(StateInfo *si, int level, int nburn, string filename, int keypos);

    //! Copy constructor
    Ensemble(const Ensemble&);

    //! Destructor
    virtual ~Ensemble() {}

    //+ CLIMETHOD void Reset StateInfo*
    //! Reinitialize the Ensemble
    virtual void Reset(StateInfo *si);

    //+ CLIMETHOD void Reset StateInfo* int int string int
    //! Reinitialize the Ensemble
    virtual void Reset(StateInfo *si,
		       int level, int nburn, string filename, int keypos);

    //+ CLIMETHOD void setDimensions StateInfo*
    //! Set total size of arrays and reset state metadata
    virtual void setDimensions(StateInfo *si);

    
    //+ CLIMETHOD void setContinuous
    //! Set multiple component range to continuous
    virtual void setContinuous();

    //+ CLIMETHOD void setMaxRange
    //! Set multiple component range to maximum range (allow zero freq. states)
    virtual void setMaxRange();

    //+ CLIMETHOD void setNKeep int
    //! Set the maximum number of states to keep in cache
    virtual void setNKeep(int n) { keep = n; }

    //+ CLIMETHOD void Order int
    /** Order the mixture by the given component 
	n<0  is the weight
	n>=0 is the parameter vector index
    */
    virtual void Order(int n);

    //+ CLIMETHOD void setVerboseOn
    //! Diagnostics for intermediate computation
    virtual void setVerboseOn() { verbose = true; }

    //+ CLIMETHOD void setVerboseOff
    //! Turn off intermediate computation diagnostics
    virtual void setVerboseOff() { verbose = false; }

    //+ CLIMETHOD void setVerboseDebugOn
    //! Verbose diagnostics for KDE methods
    virtual void setVerboseDebugOn() { verbose_debug = true; }

    //+ CLIMETHOD void setVerboseDebugOff
    //! Turn off verbose diagnostics for KDE methods
    virtual void setVerboseDebugOff() { verbose_debug = false; }

    //! Adds a state to the deque
    virtual bool AccumData(vector<double>& prob_values, State& state_vector);
    
    //! Adds a state to the deque (using StateData structure)
    virtual bool AccumData(StateData &s) {
      return AccumData(s.prob, s.p);
    }
    
    //! Required member but not used here
    virtual bool AccumulateData(double v, RecordBuffer* datapoint) { 
      cerr << "Not implemented for an Ensemble . .  \n";
      return false; 
    }

    /** 
	@name ComputeDistribution
	Computes the covariance matrix and its eigenvalues/vectors
	
	Return = 1 (variance computed), Return = 0 (too few values)
    */
    virtual void ComputeDistribution() {}
    virtual void ComputeDistribution(int n) 
    { burnIn=n; ComputeDistribution(); }
    
    /**
       Returns the mean and variance for the posterior probabilties
       for the last $n$ states in the ensemble.  If $n$ is less the
       number of states in the deque, the whole deque is used.  If the
       number of states is less than 2, zero vales are returned.
    */
    virtual void stats(int n, double& m, double& s);

    virtual int Nstates() { return states.size() + offset; }

    virtual int Npopped() { return offset; }

    virtual double PDFSubspace(unsigned m);

    virtual set<int> getValidSubspaceMixtures() { return npop; }

    //! Access to state list
    virtual deque<StateData>& getStates() { return states; }

    //! Access to StateInfo instance
    virtual StateInfo *getStateInfo() const { return _si; }

    //! Log of differential distribution function
    virtual double logPDF(State &p) 
    { return -INFINITY; }

    /** Log of differential distribution function for a component in
	@param m subspace, @param n component, and @param V parameter vector

	This method is used by ReversibleJump classes.
    */
    virtual double logPDFMarginal(unsigned m, unsigned n, 
				  const vector<double>& V) 
    { return -INFINITY; }

    //! Object factory (clone)
    virtual Ensemble* New() {
      return new Ensemble(_si);
    }

    //! Retrieve the mean per subspace
    virtual vector<double> Mean(unsigned m)
    { return vector<double>(_si->Ndim, 0.0); }

    //! Retrieve the std dev per subspace
    virtual vector<double> StdDev(unsigned m)
    { return vector<double>(_si->Ndim, 0.0); }

    //! Retrieve the std dev
    virtual vector<double> StdDev(void)
    { return Distribution::StdDev(); }

    //! Retrieve the mean
    virtual vector<double> Mean(void)
    { return Distribution::Mean(); }

    //@{
    //! Sample the distribution
    virtual State Sample() { return Sample(sampleSubspace()); }

    virtual State Sample (unsigned m) { return Distribution::Sample(); }
    //@}

    //! Sample from marginalized component number distribution
    virtual unsigned sampleSubspace();
    //@}

    //! Width
    virtual vector<double> Width(unsigned m) { return StdDev(m); }

    //+ CLIMETHOD clivectord* WidthVector int
    //! Width [cli version]
    virtual clivectord *WidthVector(int m) {
      clivectord *v = new clivectord(vector<double>(StdDev(m)));
      return v;
    }

    //+ CLIMETHOD void printWidth int
    //! Print Width for info
    virtual void printWidth(int m)
    {
      ComputeDistribution();
      if (myid) return;
      if (cnts.find(m) != cnts.end()) {
	vector<double> v(StdDev(m));
	for (unsigned i=0; i<v.size(); i++) {
	  cout << setw(3) << i << "> " << v[i] << endl;
	}
      } else {
	cout << "No subspace for " << m << endl;
      }
    }

    //+ CLIMETHOD void printWidth
    //! Print Width for info
    virtual void printWidth()
    {
      ComputeDistribution();
      if (myid) return;
      for (mapIIiter m=cnts.begin(); m!=cnts.end(); m++) {
	cout << "********** " << m->first << " **********" << endl;
	vector<double> v(StdDev(m->first));
	for (unsigned i=0; i<v.size(); i++) {
	  cout << setw(3) << i << "> " << v[i] << endl;
	}
      }
    }

    //! Retrieve the std dev for the component marginal
    virtual vector<double> StdDevMarginal(unsigned m, unsigned n)
    { return Distribution::StdDev(); }

    //! Retrieve the mean for the component marginal
    virtual vector<double> MeanMarginal(unsigned m, unsigned n)
    { return Distribution::Mean(); }

    //! Sample the distribution for the component marginal
    virtual vector<double> SampleMarginal(unsigned m, unsigned n) 
    { return Distribution::Sample(); }

    //! Width
    virtual vector<double> WidthMarginal(unsigned m, unsigned n) 
    {return vector<double>(_si->Ndim, 0.0); }

    //@{
    //+ CLIMETHOD void PrintDiag
    //+ CLIMETHOD void PrintDiag string
    //! Print current covariance matrix (debug and diag)
    virtual void PrintDiag(ostream& out) {}
    virtual void PrintDiag(string& outfile) {}
    virtual void PrintDiag();
    //@}
			    
    //! Check existence of subspace for m
    virtual bool Exists(int m) { return cnts.find(m) != cnts.end(); }

    //! Copy state to all nodes
    virtual void Broadcast();

    //@{
    //! Dump states (for debugging)

    //+ CLIMETHOD void enableDump
    void enableDump()  { enable_dump = true; }

    //+ CLIMETHOD void disableDump
    void disableDump() { enable_dump = false; }

    //+ CLIMETHOD void binaryDump
    void binaryDump()  { binary_dump = true; }

    //+ CLIMETHOD void asciiDump
    void asciiDump()   { binary_dump = false; }

    //+ CLIMETHOD void statesToFile string bool
    void statesToFile(string filename, bool binary) { 
      bool type = binary_dump;  binary_dump = binary;
      dumpStates(filename); 
      binary_dump = type;
    }

    
    //+ CLIMETHOD void dumpStates string
    //+ CLIMETHOD void dumpStates string int
    //+ CLIMETHOD void dumpStates string int int
    void dumpStates(const string& filename, 
		    int beg=0, int end=MAXINT) const;
    //@}

    //+ CLIMETHOD void PrintDensity int int int int string
    //! Density image (for debugging) using state vector with peak
    //! probability as the default
    virtual void PrintDensity(int dim1, int dim2, int num1, int num2,
			      string file) {}

    //+ CLIMETHOD void PrintDensity int int int int clivectord* string
    //! Density image (for debugging) with user supplied default state
    //! vector
    virtual void PrintDensity(int dim1, int dim2, int num1, int num2,
			      clivectord* def, string file) {}

    //+ CLIMETHOD clivectord* getMaxLikeState
    //! Return the state (from the converged distribution if possible)
    //! with the maximum likelihood value
    virtual clivectord *getMaxLikeState();

    //+ CLIMETHOD clivectord* getMaxProbState
    //! Return the state (from the converged distribution if possible)
    //! with the maximum likelihood value
    virtual clivectord *getMaxProbState();

    @persistent_end
  };

  //! A shared pointer for the StateCache class
  typedef boost::shared_ptr<StateCache> CachePtr;

  BOOST_SERIALIZATION_SHARED_PTR(StateCache)
  BOOST_SERIALIZATION_SHARED_PTR(Ensemble)

} // namespace BIE


#endif
