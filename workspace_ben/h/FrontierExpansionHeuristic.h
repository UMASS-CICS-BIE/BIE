// This is reall -*- C++ -*-

#ifndef FrontierExpansionHeuristic_h
#define FrontierExpansionHeuristic_h

#include "Serializable.h"


#include <BaseDataTree.h>

namespace BIE {
  class BaseDataTree;

  //+ CLICLASS FrontierExpansionHeuristic
  /** When presented with the possible expansion (increase of
      resolution) of a node in the tessellation tree, tree expansion
      heuristics decide whether the expansion is worthwhile.
  */
  class FrontierExpansionHeuristic: public Serializable
  {
  public:
    //! Destructor
    virtual ~FrontierExpansionHeuristic() {}

    /** Expand the frontier by moving it from the current tile to its
	children
    */
    virtual bool expandTile(vector<int> children, int parenttile) = 0;

    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    protected:
    FrontierExpansionHeuristic() {}
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Serializable);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  };

  //+ CLICLASS AlwaysIncreaseResolution SUPER FrontierExpansionHeuristic
  //! A frontier mutator
  //! 
  //! Expand the frontier by moving it from the current tile to its
  //! children
  class  AlwaysIncreaseResolution : public FrontierExpansionHeuristic 
  {
  public:
    //+ CLICONSTR
    AlwaysIncreaseResolution() {}
    
    virtual bool expandTile(vector<int> children, int parent);

    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(FrontierExpansionHeuristic);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  }; 

  //+ CLICLASS KSDistanceHeuristic SUPER FrontierExpansionHeuristic
  //! KS Distance based heuristic.
  //! 
  //! This heuristic computes the KS statistic between each pair of child 
  //! distributions proposed for expansion.  The KS statistic gives the 
  //! probability that two distributions come from the same underlying distribution
  //! If the KS statistic for any pair of child distributions is lower than the 
  //! threshold, then the method recommends increasing the resolution of the tile,
  //! because their is sufficient evidence supporting the hypothesis that the
  //! distributions are different (and if they are different we want to look more
  //! closely).
  //! Setting a threshold at the 1% level would probably be pessimistic, since 
  //! in this case expansion would not be recommended unless there was very good
  //! statistical evidence suggesting the distributions are different (from
  //! the rejection of the null hypothesis).  The question of what a good 
  //! value would be is still open.
  class  KSDistanceHeuristic : public FrontierExpansionHeuristic 
  {
  public:
    //+ CLICONSTR BaseDataTree* double
    //! Constructor
    KSDistanceHeuristic(BaseDataTree * fulldist, double threshold) 
    { this->fulldist = fulldist; this->threshold = threshold;}
    
    /** Expand the frontier by moving it from the current tile to its
	children
    */
    virtual bool expandTile(vector<int> children, int parent);

  private:
    double threshold;
    BaseDataTree * fulldist;

    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    protected:
    KSDistanceHeuristic() {}
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(FrontierExpansionHeuristic);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(threshold);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(fulldist);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  };

  //+ CLICLASS DataPointCountHeuristic SUPER FrontierExpansionHeuristic
  //! This heuristic is based on the number of points contained in each tile.
  //! Expansion is recommended until the number of points in a tile drops 
  //! below a threshold.  This heuristic will therefore be useful where
  //! there is empty space in the area being studied since the frontier
  //! will only descend to a high resolution in the densely populated parts.
  class  DataPointCountHeuristic : public FrontierExpansionHeuristic 
  {
  public:
    //+ CLICONSTR BaseDataTree* int
    //! Constructor
    DataPointCountHeuristic(BaseDataTree * fulldist, int threshold) 
    { this->fulldist = fulldist; this->threshold = threshold;}
    
    /** Expand the frontier by moving it from the current tile to its
	children
    */
    virtual bool expandTile(vector<int> children, int parent);

  private:
    int threshold;
    BaseDataTree * fulldist;

    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    protected:
    DataPointCountHeuristic() {}
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(FrontierExpansionHeuristic);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(threshold);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(fulldist);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  };  
}

BIE_CLASS_ABSTRACT(BIE::FrontierExpansionHeuristic)

#ifndef SWIG
BIE_CLASS_TYPE_INFO(BIE::AlwaysIncreaseResolution)
BIE_CLASS_TYPE_INFO(BIE::KSDistanceHeuristic)
BIE_CLASS_TYPE_INFO(BIE::DataPointCountHeuristic)
BIE_CLASS_EXPORT_KEY(BIE::FrontierExpansionHeuristic)
BIE_CLASS_EXPORT_KEY(BIE::AlwaysIncreaseResolution)
BIE_CLASS_EXPORT_KEY(BIE::KSDistanceHeuristic)
BIE_CLASS_EXPORT_KEY(BIE::DataPointCountHeuristic)
#endif

#endif
