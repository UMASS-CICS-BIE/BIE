// This is really -*- C++ -*-

#ifndef Distribution_h
#define Distribution_h

#include <BIEconfig.h>
#include <gvariable.h>
#include <RecordBuffer.h>
#include <RecordType.h>
#include <BIEException.h>
#include <State.h>

#include "Serializable.h"


namespace BIE {
  
  //! @defgroup distribution Probability distributions
  //! These classes implement various types of probability distributions
  //! @{

  //+ CLICLASS Distribution
  //! Abstract class that defines the general properties of a distriubtion
  class Distribution: public Serializable 
  {

  public:

    /** Proposal type for Metropolis-Hastings width computation

	In the description below, \f${\cal R}\f$ is a random sample from 
	(-1, 1), \f${\cal N}\f$ is a sample from the normal distribution 
	with zero mean and unit variance, and \f$\epsilon\f$ is the width 
	prefactor 
    */
    enum ProposalType { 
      UniformAdd,	  //< adds \f$\epsilon{\cal U}\f$ to the value
      UniformMult, //< multiplies the value by \f$(1 + \epsilon{\cal U})\f$
      NormalAdd,   //< adds \f$\epsilon{\cal N}\f$
      NormalMult, //< multiplies the value by \f$(1 + \epsilon{\cal N})\f$
      Undefined	//< denotes that no width type is defined (this will throw an exception if an MH step is attemped
    };

    //! Default blank constructor
    Distribution() : _type(Undefined) {}
  
    //! Force runtime binding of inherited destructor
    virtual ~Distribution() {};
    
    //! Object factory (clone)
    virtual Distribution* New() {return (Distribution*)0;};
    
    //! Differential distribution function P(x)
    virtual double PDF(State&) {
      throw InternalError(__FILE__, __LINE__); 
      return 0;
    }

    //! Log of differential distribution function P(x)
    virtual double logPDF(State&) { 
      throw InternalError(__FILE__, __LINE__); 
      return 0;
    }
    
    //! Cumulative distribution function P(>x).  
    //! Throws exception if not appropriate.
    virtual double CDF(State&) {
      throw InternalError(__FILE__, __LINE__); 
      return 0; 
    }
    
    //! Lower bound on distribution (in each dimension)
    virtual vector<double> lower(void) {return (vector<double>)0;};

    //! Upper bound on distribution (in each dimension)
    virtual vector<double> upper(void) {return (vector<double>)0;};
  
    //! Return mean of distribution (mulitvariate)
    virtual vector<double> Mean(void) {return (vector<double>)0;};

    //! Return standard deviation of distribution (mulitvariate)
    virtual vector<double> StdDev(void) {return (vector<double>)0;};
  
    //! Return specifided momemnt of distribution (mulitvariate)
    virtual vector<double> Moments(unsigned) {return (vector<double>)0;};
  
    //! Return random variate from distribution
    virtual State Sample(void) {return State(vector<double>(1));}
  
    //! Override default width
    virtual void setWidth(double x) {};
  
    //! Return the proposal type
    virtual ProposalType Type() const { return _type; }

    //! Return the dimensionality
    virtual unsigned Dim() { return lower().size(); }

  protected:
    /** Defines the Metrpolis-Hastings proposal width generator for
     *  this distribution, see Distribution::ProposalType.
     */
    ProposalType _type;

    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Serializable);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  };
  
  //+ CLICLASS SampleDistribution SUPER Distribution
  /**
     Abstract: estimate distribution from accumulated data
  */
  class SampleDistribution : public Distribution 
  {

  public:
    
    //! Force runtime binding of inherited destructor
    virtual ~SampleDistribution() { if (recordtype != 0) delete recordtype; }
  
    //! Cumulative distribution function P(>x).  
    //! Throws exception if not appropriate.
    virtual double CDF(vector<double> &) 
    { throw InternalError(__FILE__, __LINE__); return 0; };

    //! Clone (factory) function
    virtual SampleDistribution* New() {return (SampleDistribution*)0;};
  
    //@{
    /** Accumlulate data:
	Value or state may be dummy in some applications.
	returns true if data is used in distribution
    */
    virtual bool AccumData(double value, vector<double>& state) {
      vector<double> v(1, value);
      return AccumData(v, state);
    }
    virtual bool AccumData(vector<double>& value, vector<double>& state) {
      cout << "SampleDistribution: dummy\n";
      return true;
    }
    //@}

    /**
       Accumlulate data from a data point held in a record buffer
       and increment data set size.
    */
    virtual bool AccumData(double v, RecordBuffer* datapoint) {
      bool result = AccumulateData(v, datapoint);
      if (result) datasetsize++;
      return result;
    }

    //! Compute distribution estimate as needed
    virtual void ComputeDistribution() {};
    
    /** @name Iterators
	Need this for iterating through data list.  Can be either
	bins, points, coefficients, etc.
    */
    //@{
    //! Number of datums
    virtual int numberData() {return 0;}
    //! Value for the ith component
    virtual double getValue(unsigned i) {return 0.0;}
    //! Dimension for the ith component
    virtual int getdim(unsigned i) {return 1;}
    //@}

    //! Returns the record type describing the fields used by a distribution.
    virtual RecordType * getRecordType() { return recordtype; }
  
    //! Returns the total number of data points used in distribution
    virtual int getDataSetSize() { return datasetsize; }

  protected:
    //! Constructor - should only be used by subclasses during their
    //! creation, and not by other classes.
    SampleDistribution() { datasetsize = 0; recordtype = 0;}
  
    //! The number of data points used whilst building the binned distribution.
    int datasetsize;

    //! The type describing the data stored in the distribution.
    RecordType * recordtype;
  
    //! This is implemented in subclasses.
    virtual bool AccumulateData(double v, RecordBuffer* datapoint) {
      { throw InternalError(__FILE__, __LINE__); return false; };
    }

    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Distribution);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(datasetsize);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(recordtype);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  };
  
  //+ CLICLASS BinnedDistribution SUPER SampleDistribution
  /**
     Abstract: sample distribution with bins
  */
  class BinnedDistribution : public SampleDistribution 
  {
  
  public:  
    //! Force runtime binding of inherited destructor
    virtual ~BinnedDistribution() { }
  
    //! Clone (factory) function
    virtual BinnedDistribution* New() {return (BinnedDistribution*)0;}

    //@{
    /** @name Iterator extensions
	Return bin boundaries for each bin
    */
    virtual vector<double> getLow(unsigned i) {return vector<double>(1, 0.0);}
    virtual vector<double> getHigh(unsigned i) {return vector<double>(1, 0.0);}
    //@}

    /** Cumulative distribution function P(>x).  
	Throws exception if not appropriate. */
    virtual double CDF(vector<double> &) 
    { throw InternalError(__FILE__, __LINE__); return 0; };
  
  protected:
    //! Constructor only for use by subclasses.
    BinnedDistribution() {}
    
    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SampleDistribution);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

  };

  
  //+ CLICLASS PointDistribution SUPER SampleDistribution
  /**
     Sample distribution with individual points
  */
  class PointDistribution : public SampleDistribution {
  
  public:
  
    //+ CLICONSTR string
    //! Constructor
    PointDistribution(string name);
  
    //+ CLICONSTR RecordType*
    //! Constructor
    PointDistribution(RecordType* type);
  
    //! Force runtime binding of inherited destructor
    ~PointDistribution() {}

    //! Clone (factory) function
    PointDistribution* New();
  
    //! Returns the record type describing the fields used by a distribution.
    RecordType * getRecordType() { return recordtype; }

    //! Accumlulate data from a data point held in a record buffer
    bool AccumData(double v, RecordBuffer* datapoint) {
      return AccumulateData(v, datapoint);
    }
  
    //! Number of attribute fields
    int getdim(unsigned i) {return data.size();}

    //! Number of data
    int numberData() {if (full) return 1; else return 0;}
    
    virtual double getValue(unsigned i) {return data[i];}
  
    //! Return data point
    vector<double>& Point(void) {return data;};

    /** Cumulative distribution function P(>x).  
	Simply the result of integrating the n-dimensional function
	from -infinity to v
    **/
    double CDF(vector<double> &v);

  protected:  

    //@{
    //! Copy data point
    bool AccumulateData(double v, vector<double>& x);
    bool AccumulateData(double v, RecordBuffer * datapoint);
    //@}
  
    //! Data vector
    vector<double> data;
  
    //! Distribution is full
    bool full;

    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    protected:
    PointDistribution() {}
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SampleDistribution);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(data);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
         try {                                                         
          ar & BOOST_SERIALIZATION_NVP(full);                        
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

 };
  
  //+ CLICLASS NullDistribution SUPER SampleDistribution
  /**
     An eternally empty distribution
  */
  class NullDistribution : public SampleDistribution {
  
  public:
  
    //+ CLICONSTR
    //! Constructor
    NullDistribution() {}
  
    //! Force runtime binding of inherited destructor
    virtual ~NullDistribution() {}

    //! Clone (factory) function
    NullDistribution* New() { return new NullDistribution(); }
  
    #ifndef SWIG
    // AUTO GENERATED BY ../persistence/autopersist.py
    private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version) {
        this->pre_serialize(ar, version);
         try {                                                         
          ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SampleDistribution);            
          BIE_CATCH_BOOST_SERIALIZATION_EXCEPTION;                     
         }                                                             
        this->post_serialize(ar, version);
    }
    #endif

 };
  
  //! @}

} // namespace BIE

#ifndef SWIG
BIE_CLASS_TYPE_INFO(BIE::Distribution)
BIE_CLASS_TYPE_INFO(BIE::SampleDistribution)
BIE_CLASS_TYPE_INFO(BIE::BinnedDistribution)
BIE_CLASS_TYPE_INFO(BIE::PointDistribution)
BIE_CLASS_TYPE_INFO(BIE::NullDistribution)
BIE_CLASS_EXPORT_KEY(BIE::Distribution)
BIE_CLASS_EXPORT_KEY(BIE::SampleDistribution)
BIE_CLASS_EXPORT_KEY(BIE::BinnedDistribution)
BIE_CLASS_EXPORT_KEY(BIE::PointDistribution)
BIE_CLASS_EXPORT_KEY(BIE::NullDistribution)
#endif
#endif

